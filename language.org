// TODO pipe input to scripting language handler
// TODO make a compiler for a scripting language (ast -> x86)
// TODO in-zig representation of ast for the in-zig compiler
// TODO in-zig input handling to create an AST (e.g. glfw input -> adds node to ast)
// TODO serialize function to take AST -> disk
// TODO deserialize to take disk -> AST
// TODO eval (compiles AST & jump to compiled code (requires asm to enter))
// TODO platform provided functions to display based on eval
// TODO platform provided functions to have persistent data? e.g. authoring new code persists
// in platform memory, so the script takes an input and adds a node to the platform memory as
// an 'effect'
// TODO (step 1) define what the AST will look like (grammar)
// TODO eventually should the compiler be in the language itself?

// IDEA: SMIRC is two parts, functional part (scripting language domain) and a non functional part (host/platform in zig in this case)
// the functional part is just expressions that evaluate to return values, that's it. No effects.
// The non-functional part is the thing sparking the evaluation and interpretting the results through effects like displaying them.

// So if you want to write some script to display something then you basically need to return what you want displayed. The actual
// effects are interpretted by the platform.

// The nice part of designing the language in a functional way is you can describe it purely in terms of expressions instead of
// statements that do something. It just simplifies it

// This means a basic loop in the host might be:
while (true) {
    input = getAllInput();
    ret = enterScript(input); // context switch to the scripting language, get the return value
    // interpret the return value
    for (all render items in ret) {
        render(item)
    }

    for (all code edits in ret) {
        applyEdit();
    }
}

// We may want to provide functions to the scripting language, but functions must be expressions
// so they jsut return values to the scripting language rather than have effects
// this could be used to get values like query existing state that you're editing?
// So you can query into persistent data

// Another model might be to not only pass in input into the enterScript() function but pass in
// the world state that you're allowing edits to. And the return value returns the world state
// that you should store given the input.

// e.g. if you had an empty buffer world state, but you get the input 'a' then you add the 'a' character
// into the word state and return it, all that processing is done in script.

// This could look a little more like this:
state = {}
while (true) {
    input = getAllInput();
    state = enterScript(input, state); // context switch to the scripting language, get the return value
    for (state.renderItems) |item| {
        render(item);
    }
}


// THOUGHT EXPERIMENT:
// Say we simply want to make a text editor that contains a single buffer (string) of characters
// that is displayed to the user. We want a-z to append to the cursor position and backspace to
// remove, arrow keys to change cursor position.
// Can we describe all the necessary mechanisms in software to accomplish this using the platform+language model?
- memory model of the buffer (contiguous array of characters)
- need to be able to render the string. One option is the state the language has
  access to is well known to the platform, so that it can only ever produce a
  string as a return value. The platform can therefore simply iterate the string
  with dedicated string-rendering code using vulkan API and pre-initialized
  textures for glyphs etc, making a draw call with push constants each time (or
  another text rendering setup - irrelevant).
- But supposing that you want to extend the ability to render more than text, a
  hardcoded rendering approach loses some value. if you want to be able to
  describe render items using the language and potentially create dynamic
  textures, update shader code, render diagrams with vector representations then
  you would need to extend the accessibility of the renderer to the language in
  each case. You could possibly make a vector renderer for note taking with a
  small set of rendering primitives, e.g. render curves, lines, textures would
  get you quite far. So in other words you're not working directly with vertex
  data or shaders with this set and you can implement a feature-full renderer
  with pretty much everything you'd need.
 - UNLESS you wanted to experiment with shaders or rendering meshes with
   specific vertex attributes that are generated by the program etc. In this
   case it makes sense to extend even lower by allowing the language to specify
   vertex data in arbitrary formats, specify draw calls using vertex data, specify
   shaders to use etc. This is basically providing a thinner wrapper over vulkan to
   the language and gives complete flexibility. You could implement the previous set
   of features in the language itself using this lower-level interface and use that
   for ergonomics when you're doing the common tasks.
 - I'm having trouble imagining a functional language that can sufficiently provide
   information to a renderer to accomplish rendering tasks without sacrificing
   critical performance. E.g. to efficiently render text we need to first create
   a texture, have a texture sampling shader in place, make a series of draw calls
   using vulkan command submission to see the text displayed. I can imagine if
   the platform using the loops above provides an interface like "give me an array
   of objects to render, I'll iterate them and handle the rest" then you could
   accomplish the hardcoded text rendering very easily. But how can the scripting
   language accomplish the more general lower level interface where you can specify
   vertex data and then specify draw calls? Specifically how could you reference
   already-specified vertex data (that has been uploaded to the gpu) when making
   the draw calls, and how do we avoid re-uploading data that already exists and
   hasn't been modified if we're returning all of the render state with each update?
   This makes me immediately lean towards just returning edits to the state and
   not reconstructing the entire state. Or at least in terms of the things that the
   language doesn't directly control/manage: e.g. renderer in the platform manages
   active textures, vertex data, etc. If you want to add to that set then you do it
   once when necessary via returning special values with relevant data to the renderer
   in the return loop, and then you can get readable information to use later on.
 - The mental model then becomes some stuff is managed outside of the 'state' that is
   passed in to the language (managed by the platform itself and not necessarily visible
   at all to the language) and some stuff is managed directly by the language and manipulated
   in memory by the language indirectly, via the returned, new, state passed back to
   the platform in each update. In addition to passing back anything persistent that
   should be part of the input to the next run-through of the language program in the
   next loop, you can pass back special values that make one-time edits in the platform
   itself. From the language's point of view these might impact the input in the next
   iteration or might not (e.g. draw calls have no change to input, but maybe you want
   to add vertex data and then handles to the vertex data will be present in the next
   input loop)

With that in mind, here's what the loop might look like:

platform_var1 = blah; // could be vertices
platform_var2 = blah; // could be indices
platform_var3 = blah; // could be textures
state = {} // state manipulated by the guest language
while (true) {
    let renderHandles = processHandles(platform_var1, ...);
    let ret = enterLanguage(state, renderHandles);
    for (ret.renderRequests) |request| {
        // this any render data or more generally does any platform effects
        // that are required (e.g. could queue audio or quit the app)
        processRequest(request);
    }

    // This is with the model where the language fully recreates the state
    // that it uses for processing. With the edit-based model, we could
    // explore state being set via a request, and possibly we could do both
    // where state is first set from reconstruction return value, and then
    // modified by a request before being passed in. That way we wouldn't
    // need to do stuff like pass in render handles that are not managed
    // by the language itself but it's essentially the same thing: giving
    // more input from the platform to the programming language.
    state = ret.state;
}

// That might look like this:
platform_var1 = blah; // could be vertices
platform_var2 = blah; // could be indices
platform_var3 = blah; // could be textures
state = {} // state manipulated by the guest language
while (true) {
    ret := enterLanguage(state);
    state := ret.state;
    for (ret.requests) |request| {
        // this any render data or more generally does any platform effects
        // that are required (e.g. could queue audio or quit the app)
        // With this model (difference from above) we can also edit state directly from
        // the platform, so some of those requests might do that.
        // A use case for that would be we don't need renderHandles directly anymore
        // as we can just use the state as input to the programming language.
        processRequest(request, state);
    }
}

// We can take that even further:
// we don't need to have a return value that has state and requests as separate,
// if we're allowed to edit the state from the platform then we can just return
// a single value with all the information in it, and modify it before returning
// back to the programming language, so now we don't need 'ret':
platform_var1 = blah; // could be vertices
platform_var2 = blah; // could be indices
platform_var3 = blah; // could be textures
state = {} // state manipulated by the guest language
while (true) {
    state := enterLanguage(state);
    for (state.requests) |request| {
        processRequest(request, state);
    }
    // clear requests
    state.requests = {}
}

// Note that the ability to modify language state directly from the platform is required
// for the latest two models and we're not gaining very much from it, yet, at least.
// Sure it simplifies the code a tiny bit but the program is not actually doing anything
// different than if we were to provide more input variables and get more output variables

// Also I left out user-input from the platform as an input into the guest language in these
// examples but that would also need to be passed in.

Another option:
- do the same as the latest, but don't clear the requests on the host. Requests must be read
  on the host but they don't need to be cleared. You can let the guest language clear those
  requests if they are a part of the state - and you don't need to clear them if you don't want, e.g.
  if you want to request in the next loop the same thing - repeat the last draw calls for example
  then you could do that. Note that you wouldn't want to repeat stuff like adding vertex data.
  (note, the reason we can clear on the guest is that you know anything passed in has been seen already,
   and you can ignore)
- NOTE: this doesn't change the fact that the host language must know where the requests are in order
  to interpret them, and also must know how to interpret them. This might mean reading into guest
  data structures...



QUESTION: - what about audio???? answer: the above examples make audio requests pretty easy
QUESTION: - what about compilation? Is this a host function exposed to the guest? Initially the
            compiler will indeed be in zig not in the language itself, but eventually it could
            be self hosting compiler. But what about the memory associated with compilation -
            and does compilation itself have long-lasting effects? I think in order to make
            the function inline it would need to just return a code object that has all the
            program assembly & type info known. So compile takes ast -> returns code object that
            can be called. Code objects can be stored in the state for long lasting effects.
            If you want to do something like go-to-function later on when editing, then you would
            need to keep around name information etc.

* COMPILATION
- compiler must be implemented in another language before it is self hosting.
- zig works or any language that can interop with zig. Lua might be a nice language to try before
  self hosting but it makes a bit more sense to use zig if eventually I'm going to strip out lua
  when I can make the compiler self hosting. It's gotta be a hassle to setup lua interop in zig
  for the first time before I see the benefits of using a high level language for the compiler
- The compiler will take AST and return code objects (assembled sequential machine code + metadata)
- Each AST 'program' that is compiled will be a function that can be called if you move the addr
  into PC. Question: Are you allowed to move user pointers into PC?


** Efficient Compilation
How do we incrementally/just in time compile changed code using a diff without doing work that we
don't need to be doing?

E.g. say you change how one function works by making an edit in the guest language to the code, when
do we compile that and how do we produce a compiled result given what we already have compiled, efficiently?

Do we do the AST edit in the guest layer and then the compilation only when we return from the loop? or
when we make the edit in the guest layer are we compiling right there? I think that is preferable, and
we can implement that if we have a function like compile(ast) available to the guest layer. It would
have an 'effect' in that it is allocating host/platform memory, but I think that is still considered
functional?.

NOTE: eventually if the language is self hosted then the thing doing the compiling will need to be in
the guest from what I gather unless you're self hosting by having two instances of the guest language,
one that does the compiler and is managed separately by the platform to compile code that is written in
the other isntance. That seems unnecessary, but might actually be useful for a 'trusted compiler'. E.g.
you may not want the compiler to be able to rewrite itself, if you want guarantees that the code ends up
being well formed at the time of entry from the host platform. The platform may not want to jump into
arbitrary void* code unless it's confident that it was compiled correctly.

Anyways for now we can think about a compiler in zig and trust it enough if we structure this correctly:
NOTE: Ideally ensure the way we structure this program in its entirety, we won't have a way to make
zig enter into code that it does not trust (e.g. ensure we enter into code that has been compiled by
the language compiler - how can we guarantee that no user input can violate that?)

Stepping back to how to do compilation at all: I think we need the function, in zig to start:
fn compile(ast) -> machineCodeObj

Or have stricter types like (machineCodeObj that returns a value of type X)

*** Example
In the main zig loop you enter into a machineCodeObj using asm:

let machineCodeObj = state.entryPoint; // grab the machineCodeObj from the well-known type that state has
let offset = machineCodeObj.codeOFfset; // grab the address of the actual code (assuming there is metadata + code)

// inline assembly:
jmp offset;
// ... code executes
// ... code returns value of well known type
// stack is in known state and zig can assume the state of the stack based on the fact that machineCodeObj was supposed
// to return a 'state' object (type again should actually be machineCodeObj that returns this Type)

*** Self Modification
So not mentioned in the above example is how the state actually gets this entryPoint field initialized, and how that
entryPoint field might get set by the next iteration of the loop.

Initialization is done when we setup the first state. This needs to be bootstrapped by the platform as there is no
guest available to bootstrap itself, we can do this in some zig code. That zig code might be as simple as invoking
the compiler on an AST that we parse from a file, that file might have been written by serialization code that could
have been from an earlier iteration of the application eventually, or hand written using a simple ascii+serial language
format encoded AST.

So bootstrapping is taken care of...

What about self modification, and also being able to modify the entrypoint without wasting previous compilation so that
you can compile things quickly?

- in order to self modify based on user input, the bootstrapped initial program must be setup to respond to user input
  in a modifiable way from the beginning, or else there is no input a user can provide that does any edits.
- So that's important to note, you could bootstrap a state that cannot modify the entry point, provably, regardless of user input
  and that would actually be useful to implement applications that you don't want to be modifiable to that degree. You may
  want to have a tighter loop and user input can only do so many things, this way you could guarantee that, as long as you're
  guaranteeing what's being bootstrapped.

- Assuming we have some program bootstrapped that *can* modify the entrypoint because it's configured that certain inputs
  make certain edits to a temp AST and then another input attempts to compile and replace the active AST with the user created
  one, then we have something neat, but we still haven't outlined what's going on behind that compile function for incrementally
  applying changes

One idea is we have types readable in zig as well as in the guest language, and have the AST-type(s) known to zig such that it
can implement the function(s):
fn compile(ast) -> MachineCodeThatReturnsType

Note that if machine code that returns different things in the language have different types, then this function needs to
return objects that can be of different types. In fact you could specify the type at runtime based on user input (users
can create types) and so we can't have a template function where each MachineCodeThatReturnsType type is known at compile
time. There are potentially infinitely many such types that the compiler must be able to return. This means a mapping from
zig types to language types can't really be done as zig types must be known when the platform is compiled.

So MachineCodeThatReturnsType might just be a single zig type, with the runtime type information stored inside of it with
a well known format.

The input to this function will be the bootstrapped state's constructed AST. The state will have been modified for a bit
whilst keeping the entryPoint part of it intact until the special user input indicates to swap the temp AST contained
in the modified state to the entrypoint. In order to do that, when constructing the new state to return during the
entryPoint's evaluation, we need something like this (guest language fake syntax since I don't actually know the syntax)

// (this code is bootstrapped by default, at least in the modifiable version of the program, although another
//  application wanting to use the smirc framework would not necessarily look like this)
function entrypoint(input, state) {
   let tempAST = state.tempAST;
   if input == a then
      // Affect temp AST
      let newState = applyAction1(tempAST)
      return newState
   if input == b then
      // affect temp AST
      let newState = applyAction2(tempAST)
      return newState
   else if input == z then
      // This is the special input
      // (return a copy of the state, but this
      // time we set the entryPoint to be
      // the result of the compile function on the
      // temp AST we have.
      // NOTE: for the types to be correct, we must
      // have the type of AST also be AST-of-program-that-returns-state-type.
      // Otherwise the compiler of the initial bootstrap version of this
      // program (what is written here) will not be able to tell the
      // type of .entryPoint to ensure its codeOfState (code that returns
      // state). This is required in any smirc application.
      let newState = State{
          .entryPoint = compile(tempAST)
          .tempAST = state.AST
          .otherStuff = state.otherStuff
          .otherOtherStuff = state.otherOtherStuff
      }
      return newState
      
}


OBSERVATION:
- Writing out this fake syntax actually could give me good ideas about how I want the actual
  syntax to look, given the types of programs that I might be writing with it.
- One warning though, is that I will be hand-bootstrapping code in a text format most likely
  (or I make an AST-editor in a zig based repl beforehand) but the main idea is that I want
  this to be a graphically edited language, not a text based language. It's fine for it to
  have a text encoding, but that's not actually important to have a nicely thought out one.
  I can always change it and map old serialized programs to new formats.
- What is important for good design, then, is how the language feels to write visually in the
  expected format.
