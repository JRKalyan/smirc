SMIRC:

HOST:
- compiler for scripting language (compiles to native)
  - NOTE: another model would have the compiler implemented in the language. That could be done too, but
    seeing as I need a compiler before I can run programs in the language, we need to have a compiler of some
    sort working before that happens. Eventually if I see the benefit then I can move it to the language
    itself, I can imagine scripting control over the compilation process could be useful.
- execution environment for scripting language. I.e. the thing that calls main(). It might not be called main
  in this, and smirc actually might have MULTIPLE environments if I deem that useful. I can imagine a game
  context where you have completely separate environments or used as a scripting language in another
  application where separating environments is desired.
- implements display primitives
- provides window(s) for scripting language
- receives input from OS, passes into scripting language

LANGUAGE ENVIRONMENT:
- has a function that is called by the host given input from OS as args
- maintains state across loop iterations. Maybe this is maintained by host, and
  passed in as input and output so the host can 'maintain' it. But I guess that's
  what I meant by the language maintaining it - it should be composed to data
  that is interpretted and written to by the language, including language
  functions and types


QUESTIONS:
- how would you (and perhaps simply 'would you') implement something like magit
  that needs access to another program on your PC (git)?
  - I know this is focused on my own use, but good design might suggest I should
    care about security and not just give the language access to alter filesystem,
    call programs etc on the main PC. I'd like host to restrict access in some kind
    of way that gives some level of security with good (simple) practice on the user's
    part.
- What format does the compiler output in?
  If I want to have some code like:
  myprogram = compile("function(a, b) return a + b");
  myprogram();
  (NOTE: you would feasibly want to have something like that if you're authoring
   programs with a visual editor using smirc in the language. You first form
   a file-format of the language (that gets saved to disk) then you compile the
   file format when you want to test it. The scripting language gets control
   of all hotkeys so it needs a way to compile code. The question is, what
   does this actually do? That snippet returns the function type in-language
   (maybe we can make compile always produce functions. Maybe everything can
   be a function? or maybe everything is an expression... like lisp afaik
   - Anyways, what happens behind the scenes would potentially look like:
     - compile takes the string, the compiler embedded in host (for v1) is
       fed that string. parse tree generated, code generation (ir .. llvm .. machine
       code for this system). since it's a function we have the function prelude,
       code, postlude (return) that we can define for each function in the language.
     - this code needs to be placed into memory somewhere in byte form, the address
       needs to be included in the in-language function type (perhaps the runtime
       type of a function is only ever an address. Perhaps we maintain other
       info before that function that indicates the function's contract or something
       if we want the ability to write code that at runtime determines info about
       a function's type. Or perhaps we don't want that because the person who made
       the string should keep that info somewhere (if we're authoring a func for example).
       The function value is placed inside the variable myprogram which is a register
       or whatever the compiler decided for the code snippet, then it cal be called
       later on.
       Currently this means that the host controls where that function's memory actually
       is located so it could just have a vector<function> and a vector<u8> of bytes
       where all the functions are located if we wanted to be dumb.
- Should I consider making the host not reliant on a specific language, so people could
  implement their own forks built using say lua or lisp etc?
